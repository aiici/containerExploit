package Plugins

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

// 获取进程名通过PID
func getProcessNameByPid(pid string) string {
	data, err := ioutil.ReadFile(fmt.Sprintf("/proc/%s/comm", pid))
	if err != nil {
		return "unknown"
	}
	return strings.TrimSpace(string(data))
}

// 解析/proc/net/tcp6文件
func parseProcNetTcp6(targetProcessNames []string) (portInfo []string) {
	data, err := ioutil.ReadFile("/proc/net/tcp6")
	if err != nil {
		fmt.Println("读取/proc/net/tcp6失败:", err)
		return
	}

	seenPorts := make(map[int64]bool)
	lines := strings.Split(string(data), "\n")
	for _, line := range lines[1:] {
		if len(line) == 0 {
			continue
		}
		fields := strings.Fields(line)
		localAddress := fields[1]
		inode := fields[9]

		// 解析本地地址和端口
		addressPort := strings.Split(localAddress, ":")
		portHex := addressPort[1]
		port, _ := strconv.ParseInt(portHex, 16, 64)

		if seenPorts[port] {
			continue // 如果这个端口已经处理过，跳过
		}

		// 通过inode查找对应的进程
		processName := findProcessByInode(inode)
		for _, targetProcessName := range targetProcessNames {
			if processName == targetProcessName {
				portInfo = append(portInfo, strconv.FormatInt(port, 10))
				seenPorts[port] = true // 标记此端口已处理
				break                  // 找到匹配后就不再继续搜索其他进程名
			}
		}

	}
	return portInfo
}

// 通过inode查找对应的进程
func findProcessByInode(inode string) string {
	procs, _ := ioutil.ReadDir("/proc")
	for _, proc := range procs {
		if !proc.IsDir() {
			continue
		}
		pid := proc.Name()
		if _, err := strconv.Atoi(pid); err != nil {
			continue // 不是数字的目录忽略
		}

		fds, _ := ioutil.ReadDir(filepath.Join("/proc", pid, "fd"))
		for _, fd := range fds {
			link, _ := os.Readlink(filepath.Join("/proc", pid, "fd", fd.Name()))
			if strings.Contains(link, "socket:["+inode+"]") {
				return getProcessNameByPid(pid)
			}
		}
	}
	return "unknown"
}

func Exec(Type string) []string {
	targetProcessNames := []string{Type}
	return parseProcNetTcp6(targetProcessNames)

}
